;;#!/usr/bin/racket -- linux only
#lang racket

(require "db/helper.rkt") ;; Creates the data and passes the correct values to this file

;;
;; machine.rkt runs helper.rkt and manages the logic after receiving the data that will be use for the machine
;; updates of the db's (inventory and money-deposit) are done by writing files in the system and then reading them.
;; in helper.rkt the logic for update and reading is implemented
;;

; ;; TODO: create handlers for transaction file
; (define (start-transactions inventory transactions deposit)
;   transactions
; )

;; [start-transaction] of a single transaction file
(define (start-transaction inventory transaction)
  ;; get product in inventory and confirm it exist
  (cond
	[(product-exist? inventory transaction)"::--[Transacction completed]" ] ;; executes the transaction
	[else "::--[Transaction went wrong]"]
  )
)

;; helper function of [start-transaction]
;; if product-name exist then return true
(define (product-exist? inventory transaction)
  (cond
    ;; if inventory null then all inventory checked and product does not exist
    [(null? inventory) #f]
    [(and (equal? (caar inventory) (car transaction)) (compute-transaction (car inventory) transaction)) #t ]
    [else (product-exist? (cdr inventory) transaction) ]
  )
)

;; [compute-transaction] validates the transaction and updates de db
(define (compute-transaction inventory transaction)
  ;; (cadr transaction) is the list of transitions form '(1 1 2 5 10 20 50)
  ;; (cadr inventory) is the price form '("produc-name" price quantity) : ("gansitos" 17 2)

  (cond
    [(and (validate (cadr transaction) (cadr inventory) 0) (check-currency (cadr transaction)) ) #t ]
    [else #f]
  )

  ; (cadr transaction)
  ; (cadr inventory)
  ; (validate (cadr transaction) (cadr inventory) 0)
)

;; HERE DATA SHOULD BE UPDATED
;; current-state = money deposited by user
;; final-state = money that user should deposit
(define (validate transactions final-state current-state)
  (cond
    ;; If transactions not empty yet, then continue to add up the transactions inside the function
    [(not(null? transactions)) (validate (cdr transactions) final-state (+ current-state (car transactions)) ) ]

    ;; [[[[[[[[[[[---------- Update happens here in function that returns true ----------]]]]]]]]

    ;; validated transactions without fare to return. update inv and money using transactions data
    [(= final-state current-state) (update-everything) ]

    ;; Change automata only needs to substract the expected value of the product to the value inputed by the user
    ;; For example, if a product costs 50 and user gave 55, then the machine must return 5 (input - cost)

    ;; [[[[[[[[[[[---------- Update happens here in function that returns true ----------]]]]]]]]
    [(> current-state final-state) (fare-automata current-state final-state) ] ;; starts change automata and updates stuff

    [(< current-state final-state) #f ] ;; transaction does not buy a product and db's not updated
  )
)

(define (check-currency transactions)
  (cond
    [(null? transactions) #t]
    [(= (car transactions) 1) (check-currency (cdr transactions))  ]
    [(= (car transactions) 2) (check-currency (cdr transactions))  ]
    [(= (car transactions) 5) (check-currency (cdr transactions))  ]
    [(= (car transactions) 10) (check-currency (cdr transactions)) ]
    [(= (car transactions) 20) (check-currency (cdr transactions)) ]
    [(= (car transactions) 50) (check-currency (cdr transactions)) ]
    [else #f]
  )
)


(define (fare-automata current-state final-state) ;; in this automata the deposit has to be checked to decide what to return
    ;; debt is input - cost what the machine owes to the user
    ;; debt = (- current-state final-state)
    (define debt (- current-state final-state))
    ;; (backup-everything) makes a security copy of everything (inventory and deposit)
    (update-everything final-state) ;; adds the actual money added by the user after the security copy


  (cond
    [(= debt 0) (update-everything final-state) ] ;; [updates the money and inventory db]

    ;; caar money-deposit is coin value to update in db
    ;; cadar money-deposit is existance

    ;; If inside automata then update-money decreases the money from the deposit
    [(and (< (caar deposit) debt) (> (cadar deposit) 0)) (fare-automata current-state final-state ) ]

    [else #f] ;; does not update and returns the security-data to the document
  )
)


;; Any update function should has access to global variables inventory, transactions and deposit to update the info. input data will be data to change inside the update functions. Update writes and reads data from the system.

(define (update-money list-to-alter value ) ;
  inventory
)

(define (update-everything)
  inventory
)
;; start of the runtime code
;; HERE THE PROGRgM STARTS

; transaction
; (cln)
; inventory
; (cln)
; deposit
; (cln)

;; Creating copies
;; Run the code. If transaction fails, return copy and say transaction failed

;; [|----- TESTING AREA -----| ]

; (start-transaction inventory transaction)
; (product-exist? inventory transaction) ;; WORKING CORRECTLY
; (compute-transaction (car inventory) transaction)

(fare-automata 10 deposit)
